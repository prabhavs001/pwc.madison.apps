package com.pwc.madison.core.servlets;

import com.adobe.granite.ui.components.ds.DataSource;
import com.adobe.granite.ui.components.ds.SimpleDataSource;
import com.adobe.granite.ui.components.ds.ValueMapResource;
import com.pwc.madison.core.constants.MadisonConstants;
import com.pwc.madison.core.util.MadisonUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.jackrabbit.JcrConstants;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceMetadata;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceResolverFactory;
import org.apache.sling.api.resource.ValueMap;
import org.apache.sling.api.servlets.HttpConstants;
import org.apache.sling.api.servlets.ServletResolverConstants;
import org.apache.sling.api.servlets.SlingSafeMethodsServlet;
import org.apache.sling.api.wrappers.ValueMapDecorator;
import org.osgi.framework.Constants;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.Servlet;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Servlet to populate items in dialog's select (set {@code DataSource} attribute in request).
 * The options list is generated by iterating on the children of the {@code items} resource present under the
 * resource mentioned in the {@code path} property of the current resource.
 */
@Component(service = Servlet.class,
    property = {
        Constants.SERVICE_DESCRIPTION + "=DataSource servlet to populate items in dialog's select",
        ServletResolverConstants.SLING_SERVLET_RESOURCE_TYPES + "=pwc-madison/utilities/dialog/datasource",
        ServletResolverConstants.SLING_SERVLET_METHODS + "=" + HttpConstants.METHOD_GET
    })
public class SelectDataSourceServlet extends SlingSafeMethodsServlet {

    private static final Logger LOGGER = LoggerFactory.getLogger(SelectDataSourceServlet.class);

    private static final String DATASOURCE_RESOURCE_NAME = "datasource";
    private static final String DATA_TYPE_PROPERTY = "dataType";
    private static final String SORTING_PROPERTY ="sort";
    private static final String PATH_PROPERTY = "path";
    private static final String ITEMS_RESOURCE_NAME = "items";
    private static final String ITEM_VALUE_PROPERTY = "value";
    private static final String ITEM_LABEL_PROPERTY = "text";
    private static final String ITEM_SELECTED_PROPERTY = "selected";
    private static final String ITEMS_TERRITORY_CODE = "territoryCode";
    private static final String UNDERSCORE = "_";
    private static final String CONTENT_DATA_TYPE = "content-type";
    private static final String FIRMWIDE_TERRITORY_CODE = "fw";

    @Reference
    private ResourceResolverFactory resourceResolverFactory;

    /**
     * Set "DataSource" attribute in request
     *
     * @param request  {@link SlingHttpServletRequest}
     * @param response {@link SlingHttpServletResponse}
     */
    @Override
    protected void doGet(final SlingHttpServletRequest request, final SlingHttpServletResponse response) {

        Resource dataSourceResource = request.getResource().getChild(DATASOURCE_RESOURCE_NAME);
        ResourceResolver requestResourceResolver = request.getResourceResolver();

        request.setAttribute(DataSource.class.getName(), getDataSource(dataSourceResource, requestResourceResolver));
    }

    /**
     * Creates a {@link DataSource} of the items. Items which don't have "value" property will be ignored.
     *
     * @param dataSourceResource      current dataSource {@link Resource}
     * @param requestResourceResolver {@link ResourceResolver}
     * @return dataSource
     */
    private DataSource getDataSource(Resource dataSourceResource, ResourceResolver requestResourceResolver) {

        List<Resource> optionsFakeResourceList = new ArrayList<>();

        ResourceResolver resourceResolver = MadisonUtil.getResourceResolver(resourceResolverFactory, MadisonConstants.MADISON_READ_SUB_SERVICE);

        if (Objects.nonNull(resourceResolver)) {
            String path = dataSourceResource.getValueMap().get(PATH_PROPERTY, String.class);
            boolean isSorting = (boolean) dataSourceResource.getValueMap().getOrDefault(SORTING_PROPERTY,false);
            String dataType = (String) dataSourceResource.getValueMap().getOrDefault(DATA_TYPE_PROPERTY,StringUtils.EMPTY);
            if (StringUtils.isNotBlank(path)) {
                Resource itemsResource = resourceResolver.getResource(path + MadisonConstants.FORWARD_SLASH + ITEMS_RESOURCE_NAME);
                if (Objects.nonNull(itemsResource)) {
                    for (Resource itemResource : itemsResource.getChildren()) {
                        String itemResourceName = itemResource.getName();
                        String territoryCode = isSorting &&  dataType.equals(CONTENT_DATA_TYPE) ? itemResourceName.substring(0,itemResourceName.indexOf(UNDERSCORE)) : StringUtils.EMPTY;
                        Resource optionResource = createOptionsFakeResource(itemResource.getValueMap(), requestResourceResolver,territoryCode);
                        if (Objects.nonNull(optionResource)) {
                            optionsFakeResourceList.add(optionResource);
                        }
                    }
                }
            }
            if(isSorting) {
                optionsFakeResourceList = optionsFakeResourceList.stream().sorted((o1, o2) -> {

                            String object1TerritoryCode = o1.getValueMap().get(ITEMS_TERRITORY_CODE, String.class);
                            String object2TerritoryCode = o2.getValueMap().get(ITEMS_TERRITORY_CODE, String.class);
                            if(Objects.nonNull(object1TerritoryCode) && Objects.nonNull(object2TerritoryCode) ) {
                                if (object1TerritoryCode.equals(FIRMWIDE_TERRITORY_CODE) && !object2TerritoryCode.equals(FIRMWIDE_TERRITORY_CODE)) {
                                    return -1;
                                } else if (!object1TerritoryCode.equals(FIRMWIDE_TERRITORY_CODE) && object2TerritoryCode.equals(FIRMWIDE_TERRITORY_CODE)) {
                                    return 1;
                                }
                            }
                            return o1.getValueMap().get(ITEM_LABEL_PROPERTY, String.class).compareTo(o2.getValueMap().get(ITEM_LABEL_PROPERTY, String.class));
                        }
                ).collect(Collectors.toList());
            }
        }
       resourceResolver.close();

        LOGGER.debug("Options list for {}: {}", dataSourceResource.getPath(), optionsFakeResourceList);

        return new SimpleDataSource(optionsFakeResourceList.iterator());

    }

    /**
     * Create a fake option resource from the given {@link ValueMap}.
     *
     * @param itemResourceValueMap    {@link ValueMap}
     * @param requestResourceResolver request {@link ResourceResolver}
     * @return option resource, null if {@code value} property doesn't exist in the given value map.
     */
    private Resource createOptionsFakeResource(ValueMap itemResourceValueMap, ResourceResolver requestResourceResolver,String territoryCode) {

        String value = itemResourceValueMap.get(ITEM_VALUE_PROPERTY, String.class);
        String text = itemResourceValueMap.get(ITEM_LABEL_PROPERTY, String.class);
        boolean isSelected = itemResourceValueMap.get(ITEM_SELECTED_PROPERTY, false);

        if (StringUtils.isEmpty(value)) {
            return null;
        }
        if (StringUtils.isEmpty(text)) {
            text = value;
        }

        ValueMap valueMap = new ValueMapDecorator(new HashMap<>());
        valueMap.put(ITEM_VALUE_PROPERTY, value);
        valueMap.put(ITEM_LABEL_PROPERTY, text);
        valueMap.put(ITEM_SELECTED_PROPERTY, isSelected);
        if(Objects.nonNull(territoryCode) && StringUtils.isNotEmpty(territoryCode))
            valueMap.put(ITEMS_TERRITORY_CODE,territoryCode);

        return new ValueMapResource(requestResourceResolver, new ResourceMetadata(), JcrConstants.NT_UNSTRUCTURED, valueMap);

    }

}
